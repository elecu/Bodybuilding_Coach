#!/usr/bin/env python3
import copy
import sys
import numpy as np
import open3d as o3d

# -----------------------------
# Inputs / outputs
# -----------------------------
P_TGT = "view_0.pcd"
P_SRC = "view_2.pcd"
OUT_ALIGNED = "aligned_merged.pcd"
OUT_THICK   = "merged_thick.pcd"

# -----------------------------
# Tuning
# -----------------------------
VOX = 0.01       # meters (10mm)
D_MM = 10        # visual thickness in mm

# NEW: optional separation (mm) passed via CLI: python merge.py 20  (or -20)
SEPARATION_MM_DEFAULT = 0.0

# If you know it's front vs back, start with [180] only.
YAW_CANDIDATES = [180]  # try [180, 0, 90, 270] if needed

# Try mirroring src (left-right flip) if alignment looks "same-side"
TRY_MIRROR = True

# ICP settings
ICP_MAX_ITER = 120
ICP_DIST = VOX * 3.0    # correspondence distance

# -----------------------------
# Helpers
# -----------------------------
def preprocess(pcd: o3d.geometry.PointCloud, voxel: float) -> o3d.geometry.PointCloud:
    p = pcd.voxel_down_sample(voxel)
    p, _ = p.remove_statistical_outlier(nb_neighbors=30, std_ratio=2.0)
    p.estimate_normals(o3d.geometry.KDTreeSearchParamHybrid(radius=voxel * 4.0, max_nn=80))
    return p

def pca_basis(points: np.ndarray):
    """
    Returns orthonormal basis (up, right, forward) using PCA.
    up: largest variance axis (body height)
    right/forward: remaining axes
    """
    P = points - points.mean(axis=0, keepdims=True)
    C = (P.T @ P) / max(len(P) - 1, 1)
    w, V = np.linalg.eigh(C)            # ascending
    V = V[:, np.argsort(w)[::-1]]       # descending
    up = V[:, 0]
    right = V[:, 1]
    fwd = V[:, 2]
    # Make it right-handed
    if np.dot(np.cross(up, right), fwd) < 0:
        fwd = -fwd
    return up / np.linalg.norm(up), right / np.linalg.norm(right), fwd / np.linalg.norm(fwd)

def rot_about_axis(axis: np.ndarray, deg: float) -> np.ndarray:
    axis = axis / np.linalg.norm(axis)
    a = np.deg2rad(deg)
    K = np.array([[0, -axis[2], axis[1]],
                  [axis[2], 0, -axis[0]],
                  [-axis[1], axis[0], 0]], dtype=float)
    R = np.eye(3) + np.sin(a) * K + (1 - np.cos(a)) * (K @ K)
    T = np.eye(4)
    T[:3, :3] = R
    return T

def make_mirror_in_local_basis(center: np.ndarray, up: np.ndarray, right: np.ndarray, fwd: np.ndarray) -> np.ndarray:
    """
    Mirror across the plane spanned by (up, fwd), flipping 'right' axis.
    This is a left-right flip in the local body basis.
    """
    # Local basis matrix B maps local->world: [right up fwd]
    B = np.column_stack([right, up, fwd])  # 3x3
    # Mirror in local coordinates: flip x (right)
    M_local = np.diag([-1, 1, 1])
    # World-space mirror: B * M_local * B^T
    Rm = B @ M_local @ B.T

    T = np.eye(4)
    T[:3, :3] = Rm
    # Keep mirror around center: x' = Rm*(x-center)+center
    T[:3, 3] = center - Rm @ center
    return T

def icp_point2plane(src: o3d.geometry.PointCloud, tgt: o3d.geometry.PointCloud, init: np.ndarray):
    return o3d.pipelines.registration.registration_icp(
        src, tgt,
        max_correspondence_distance=ICP_DIST,
        init=init,
        estimation_method=o3d.pipelines.registration.TransformationEstimationPointToPlane(),
        criteria=o3d.pipelines.registration.ICPConvergenceCriteria(max_iteration=ICP_MAX_ITER),
    )

def score_solution(reg, yaw, expected_yaw=180):
    """
    Fitness alone is ambiguous for symmetric bodies. Add a prior toward expected yaw.
    """
    fitness = reg.fitness
    rmse = reg.inlier_rmse

    # Yaw prior: prefer expected_yaw (usually 180 for front/back)
    yaw_penalty = 0.0
    if expected_yaw is not None:
        # distance on circle in degrees
        d = abs(((yaw - expected_yaw + 180) % 360) - 180)
        yaw_penalty = d / 180.0  # 0..1

    # Higher is better. Penalize rmse and yaw distance a bit.
    return fitness - 0.5 * rmse - 0.15 * yaw_penalty

def thicken_along_normals(pcd: o3d.geometry.PointCloud, voxel: float, d_mm: float) -> o3d.geometry.PointCloud:
    p = pcd.voxel_down_sample(voxel * 0.8)
    p.estimate_normals(o3d.geometry.KDTreeSearchParamHybrid(radius=voxel * 4.0, max_nn=80))
    p.orient_normals_consistent_tangent_plane(30)

    pts = np.asarray(p.points)
    nrm = np.asarray(p.normals)
    d = d_mm / 1000.0

    p_plus = o3d.geometry.PointCloud()
    p_plus.points = o3d.utility.Vector3dVector(pts + d * nrm)

    p_minus = o3d.geometry.PointCloud()
    p_minus.points = o3d.utility.Vector3dVector(pts - d * nrm)

    thick = p + p_plus + p_minus
    thick = thick.voxel_down_sample(voxel * 0.7)
    thick, _ = thick.remove_statistical_outlier(nb_neighbors=30, std_ratio=2.5)
    return thick

def parse_sep_mm(default_mm: float) -> float:
    """
    CLI: python merge.py 20   (or -20)
    """
    if len(sys.argv) <= 1:
        return float(default_mm)
    a = sys.argv[1]
    if a in ("-h", "--help"):
        print(f"Usage: {sys.argv[0]} [separation_mm]\n"
              f"  separation_mm: float (mm), can be negative.\n"
              f"Examples:\n"
              f"  python {sys.argv[0]} 20     # separate front/back visually\n"
              f"  python {sys.argv[0]} -20    # bring them closer\n")
        raise SystemExit(0)
    try:
        return float(a)
    except ValueError:
        raise SystemExit(f"Invalid separation_mm: {a!r} (use e.g. 20 or -20)")

# -----------------------------
# Main
# -----------------------------
def main():
    separation_mm = parse_sep_mm(SEPARATION_MM_DEFAULT)

    tgt0 = o3d.io.read_point_cloud(P_TGT)
    src0 = o3d.io.read_point_cloud(P_SRC)
    if tgt0.is_empty() or src0.is_empty():
        raise RuntimeError("Empty PCD input")

    tgt = preprocess(tgt0, VOX)
    src = preprocess(src0, VOX)

    # Build local basis from target (more stable)
    up, right, fwd = pca_basis(np.asarray(tgt.points))

    ct = np.mean(np.asarray(tgt.points), axis=0)
    cs = np.mean(np.asarray(src.points), axis=0)

    # Candidate pre-transforms for src: normal or mirrored
    preTs = [("nomirror", np.eye(4))]
    if TRY_MIRROR:
        preTs.append(("mirrorLR", make_mirror_in_local_basis(cs, up, right, fwd)))

    best = None
    best_info = None

    for pre_name, preT in preTs:
        src_pre = copy.deepcopy(src)
        src_pre.transform(preT)

        cs_pre = np.mean(np.asarray(src_pre.points), axis=0)

        for yaw in YAW_CANDIDATES:
            Tyaw = rot_about_axis(up, yaw)
            R = Tyaw[:3, :3]

            # Rotate around src centroid, then translate to target centroid
            Tinit = np.eye(4)
            Tinit[:3, :3] = R
            Tinit[:3, 3] = ct - R @ cs_pre

            reg = icp_point2plane(src_pre, tgt, Tinit)

            sc = score_solution(reg, yaw, expected_yaw=180)
            print(f"[{pre_name}] yaw={yaw:3d}  fitness={reg.fitness:.3f}  rmse={reg.inlier_rmse:.4f}  score={sc:.4f}")

            if best is None or sc > best:
                best = sc
                best_info = (pre_name, preT, yaw, reg.transformation)

    pre_name, preT, yaw_best, Tbest = best_info
    print(f"\nBEST = pre={pre_name} yaw={yaw_best} score={best:.4f}")

    # Apply to original src0: first preT then Tbest (both are world transforms)
    srcA = copy.deepcopy(src0)
    srcA.transform(preT)
    srcA.transform(Tbest)

    # NEW: visual separation along forward/back axis (fwd), before merging
    # Positive pushes them apart, negative brings them closer.
    sep_m = separation_mm / 1000.0
    delta = fwd * (sep_m / 2.0)

    T_pos = np.eye(4); T_pos[:3, 3] =  delta
    T_neg = np.eye(4); T_neg[:3, 3] = -delta

    tgt_sep = copy.deepcopy(tgt0)
    src_sep = copy.deepcopy(srcA)
    tgt_sep.transform(T_neg)
    src_sep.transform(T_pos)

    merged = tgt_sep + src_sep
    merged = merged.voxel_down_sample(VOX * 0.8)
    o3d.io.write_point_cloud(OUT_ALIGNED, merged)
    print(f"Saved aligned merge: {OUT_ALIGNED} (separation_mm={separation_mm})")

    thick = thicken_along_normals(merged, VOX, D_MM)
    o3d.io.write_point_cloud(OUT_THICK, thick)
    print("Saved thick:", OUT_THICK)

if __name__ == "__main__":
    main()
